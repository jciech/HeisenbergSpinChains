import numpy as np
import scipy.linalg
import scipy.sparse
import scipy.sparse.linalg

# Defining the Pauli matrices to be used in our calculation
S0 = np.array([[1, 0], [0, 1]])
Sx = np.array([[0, 1], [1, 0]])
Sy = np.array([[0, -1j], [1j, 0]])
Sz = np.array([[1, 0], [0, -1]])

# Some variables chosen initally for potential calculation
# Note hbar will likely be taken to be 1. I am keeping it here should I ever need it.
dt = 1
hbar = 1.05 * np.power(10.0, -34)


def initialiseChain(N, configuration):
    """
    The function initialiseChain takes arguments N and configuration, where N is the length of our chain and
    configuration, which specifies the state we want to initialise.

    :param N: integer length of the chain
    :param configuration: np.array of length N with 1 meaning up and 0 meaning down, e.g. [1,0,0,1] means up-down=down up
    :return: np.array of length 2**N, the state vector in full state space
    """
    # Initialising the state vector, which will be represented in the full state space of the chain
    state = 1

    # Defining the states from which our specific state will be constructed from
    up = [0, 1]
    down = [1, 0]

    # The loop below constructs a vector of size 2^N through the Kronecker (tensor) product
    i = 0
    while i < N:
        if configuration[i] == 0:
            state = scipy.kron(state, up)
            i += 1
        elif configuration[i] == 1:
            state = scipy.kron(state, down)
            i += 1
        else:
            return (
                "The configuration has not been specified correctly, please read the"
                " docstring"
            )

    return state


def makeHamiltonian(N):
    """
    The function makeHamiltonian takes argument N, the length of our chain and constructs the XYZ Hamiltonian for
    a chain of that length

    :param N: integer length of the chain
    :return: 2**N x 2**N Hamiltonian of a chain of the specified length
    """
    H = scipy.zeros([2 ** N, 2 ** N], dtype=float)

    # We must loop over all nearest neighbour interactions to develop the Hamiltonian
    for interaction in range(N - 1):
        # Initialising the products which will be used to calculate the Hamiltonian matrix elements
        ProdX = 1
        ProdY = 1
        ProdZ = 1

        # The computation of the matrix elements is as follows:
        # (Almost) every interaction gains a contribution from a pair of spins, contributing an Sx, Sy and Sz term to H
        # There are N-1 interactions and for each one, we add a term which is a Kronecker product of Pauli matrices
        # if a spin participates in this interaction. Otherwise we take the Kronecker product with the identity to
        # ensure correct dimensionality of the matrix
        # It's clear we are looking at nearest neighbours below
        for site in range(N):
            if site == interaction or site == interaction + 1:
                ProdX = scipy.kron(ProdX, Sx)
                ProdY = scipy.kron(ProdY, Sy)
                ProdZ = scipy.kron(ProdZ, Sz)
            else:
                ProdX = scipy.kron(ProdX, S0)
                ProdY = scipy.kron(ProdY, S0)
                ProdZ = scipy.kron(ProdZ, S0)

        H += np.real(ProdX + ProdY + ProdZ)

    return H


def evolveState(state, hamiltonian, timestep):
    """
    The function evolveState takes an input state, as generated by initialiseChain, a Hamiltonian as generated by
    makeHamiltonian and timestep (integer or float) and returns a final state after constructing a time evolution
    operator.

    :param state: np.array of length 2**N, the state vector in full state space
    :param hamiltonian: 2**N x 2**N Hamiltonian of a chain of the specified length
    :param timestep: integer/float
    :return: evolved state: np.array of length 2**N, again in the full state space
    """
    evmat = scipy.linalg.expm(hamiltonian * -1j * timestep)
    newstate = evmat.dot(state)

    return newstate


if __name__ == "__main__":
    # We initialise the chain for 3 spins in the up-down-down configuration
    N = 4
    initialState = initialiseChain(N, [1, 0, 0, 0])
    # We create the Hamiltonian
    H = makeHamiltonian(N)
    print(H)
    # And evolve the state
    finalState = evolveState(initialState, H, dt)
